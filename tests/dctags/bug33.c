// Bug33: K&R forward declaration with void* conflicts with struct* prototype
// Error: conflicting types for 'get_schema'
//
// This bug occurs when:
// 1. precc generates K&R forward declarations for functions returning pointers
// 2. It uses generic "void *" as the return type for all pointer returns
// 3. Later, the actual prototype appears with a specific struct pointer type
// 4. In C, "void *" and "Schema *" are conflicting types for declarations
//
// Pattern from SQLite (PU 2414):
// - Line 5939: static void *sqlite3SchemaGet();  (K&R forward decl)
// - Line 6412: static Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt); (prototype)
// - These conflict because void* != Schema*
//
// Fix: K&R forward declarations should not use void* for pointer returns.
// Options:
// 1. Use the actual return type if available from prototypes
// 2. Skip K&R forward declaration if a prototype will appear later
// 3. Use generic placeholder that doesn't conflict (not possible in C)

typedef struct Schema Schema;
typedef struct sqlite3 sqlite3;
typedef struct Btree Btree;

// Forward declare a struct that will be used as return type
typedef struct MyValue MyValue;

// This simulates a K&R forward declaration generated by precc
// When precc doesn't know the exact return type, it uses void*
static void *get_schema();

// Later, the actual prototype appears (from dependency resolution)
// This conflicts with the void* declaration above
static Schema *get_schema(sqlite3 *db, Btree *pBt);

// Another example: sqlite3ValueNew pattern
static void *value_new();
static MyValue *value_new(sqlite3 *db);

// Definitions
struct Schema {
    int id;
    char *name;
};

struct MyValue {
    int type;
    int val;
};

static Schema *get_schema(sqlite3 *db, Btree *pBt) {
    static Schema s = {1, "test"};
    (void)db;
    (void)pBt;
    return &s;
}

static MyValue *value_new(sqlite3 *db) {
    static MyValue v = {0, 42};
    (void)db;
    return &v;
}

// A function that uses these
int use_schema(void) {
    Schema *s = get_schema((sqlite3*)0, (Btree*)0);
    MyValue *v = value_new((sqlite3*)0);
    if (s && v) {
        return s->id + v->val;
    }
    return 0;
}

int main(void) {
    return use_schema();
}
